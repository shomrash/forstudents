## Лекция: Поиск в массиве

### Введение
Поиск в массиве - это одна из фундаментальных операций в информатике. Он позволяет находить элементы в массиве по определенным критериям. В этой лекции мы рассмотрим основные методы поиска в массиве, их алгоритмы, а также преимущества и недостатки.

### Основные методы поиска

#### 1. Линейный поиск (Sequential Search)
**Основная идея:** Линейный поиск - это простой метод, при котором каждый элемент массива последовательно сравнивается с искомым элементом до тех пор, пока не будет найден искомый элемент или не закончится весь массив.

**Алгоритм:**
1. Начинаем с первого элемента массива.
2. Сравниваем текущий элемент с искомым.
3. Если элемент совпадает с искомым, возвращаем его индекс.
4. Если не совпадает, переходим к следующему элементу и повторяем шаги 2-3.
5. Если дошли до конца массива и не нашли искомый элемент, возвращаем -1.

**Преимущества и недостатки:**
- Прост в реализации.
- Работает с неотсортированными данными.
- Временная сложность в худшем случае O(n), где n - размер массива.

**Пример на Python:**
```python
def linear_search(arr, target):
    for i, element in enumerate(arr):
        if element == target:
            return i
    return -1

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
target = 5
result = linear_search(numbers, target)
if result != -1:
    print(f"Элемент {target} найден на позиции {result}.")
else:
    print(f"Элемент {target} не найден.")
```

**Пример на Java:**
```java
public class LinearSearch {
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int target = 5;
        int result = linearSearch(numbers, target);
        if (result != -1) {
            System.out.println("Элемент " + target + " найден на позиции " + result + ".");
        } else {
            System.out.println("Элемент " + target + " не найден.");
        }
    }
}
```

#### 2. Бинарный поиск (Binary Search)
**Основная идея:** Бинарный поиск - это эффективный метод поиска в упорядоченном массиве. Он сравнивает искомый элемент с элементом посередине массива и определяет, в какой половине массива следует продолжить поиск.

**Алгоритм:**
1. Исходный массив должен быть упорядочен по возрастанию.
2. Определяем левую и правую границы поиска: left = 0, right = n-1 (где n - размер массива).
3. Вычисляем средний элемент mid = (left + right) // 2.
4. Сравниваем элемент в позиции mid с искомым элементом:
   - Если элемент в позиции mid равен искомому элементу, возвращаем mid.
   - Если элемент в позиции mid больше искомого элемента, обновляем right = mid - 1 и переходим к шагу 3.
   - Если элемент в позиции mid меньше искомого элемента, обновляем left = mid + 1 и переходим к шагу 3.
5. Повторяем шаги 3-4 до тех пор, пока не найдем элемент или не определим, что он отсутствует в массиве.

**Преимущества и недостатки:**
- Обеспечивает временную сложность O(log n) для упорядоченных массивов.
- Эффективен для больших данных.
- Требует, чтобы массив был предварительно отсортирован.

**Пример на Python:**
```python
def binary_search(arr, target):
    left = 0
    right = len(arr) - 1
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

sorted_numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
target = 5
result = binary_search(sorted_numbers, target)
if result != -1:
    print(f"Элемент {target} найден на позиции {result}.")
else:
    print(f"Элемент {target} не найден.")
```

**Пример на Java:**
```java
public class BinarySearch {
    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (arr[mid] == target) {
                return mid;
            } else if (arr[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] sortedNumbers = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int target = 5;
        int result = binarySearch(sorted

Numbers, target);
        if (result != -1) {
            System.out.println("Элемент " + target + " найден на позиции " + result + ".");
        } else {
            System.out.println("Элемент " + target + " не найден.");
        }
    }
}
```

### Заключение
Поиск в массиве - важная операция в программировании, и выбор метода поиска зависит от характеристик задачи и данных. Каждый из методов имеет свои преимущества и недостатки, и их правильное использование помогает оптимизировать производительность программы.